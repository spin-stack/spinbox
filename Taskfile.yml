# Qemubox Containerd Runtime - Task Runner
#
# Quick Start:
#   task build           # Build everything (shim, kernel, initrd)
#   task clean           # Clean build artifacts
#   task lint            # Lint code
#
# Development:
#   task menuconfig      # Configure kernel (requires KERNEL_VERSION and KERNEL_ARCH)
#
# Requirements:
#   - Go 1.23+
#   - Docker with buildx

version: '3'

silent: true

output: "prefixed"

vars:
  GO: go
  DOCKER: docker
  BUILDX: "{{.DOCKER}} buildx"
  MODULE_NAME:
    sh: go list -m
  ROOT_DIR:
    sh: pwd
  ARCH:
    sh: uname -m
  OS:
    sh: uname -s
  OUTPUT_DIR: _output
  BIN_DIR: bin
  SCRIPTS_DIR: hack
  BUILDKIT_CACHE_DIR: '{{.BUILDKIT_CACHE_DIR | default "/var/lib/qemubox-buildkit-cache"}}'
  BUILDKIT_CACHE_KERNEL: '{{.BUILDKIT_CACHE_DIR}}/kernel'
  BUILDKIT_CACHE_INITRD: '{{.BUILDKIT_CACHE_DIR}}/initrd'
  BUILDKIT_CACHE_QEMU: '{{.BUILDKIT_CACHE_DIR}}/qemu'

  # Build flags
  LDFLAGS: "-s -w"
  GO_BUILDTAGS: "no_grpc"
  GO_TAGS: '-tags "{{.GO_BUILDTAGS}}"'
  GO_LDFLAGS: "-ldflags '{{.LDFLAGS}}'"

  # Static build flags
  GO_STATIC_BUILDTAGS: "osusergo netgo static_build no_grpc"
  GO_STATIC_TAGS: '-tags "{{.GO_STATIC_BUILDTAGS}}"'
  GO_STATIC_LDFLAGS: "-ldflags '-extldflags \"-static\" {{.LDFLAGS}}'"

tasks:
  # ==========================================================================
  # Build Tasks
  # ==========================================================================

  build:go:
    internal: true
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Building {{.NAME}}..."
        mkdir -p {{.OUTPUT_DIR}}
        CGO_ENABLED=0 GOOS=linux GOARCH=amd64 {{.GO}} build {{.GO_STATIC_TAGS}} {{.GO_STATIC_LDFLAGS}} -o {{.OUTPUT_DIR}}/{{.OUT}} {{.PKG}}
        echo "âœ“ {{.NAME}} built: {{.OUTPUT_DIR}}/{{.OUT}} (static)"

  build:
    desc: Build all components (shim, kernel, initrd, QEMU)
    deps:
      - build:shim
      - build:kernel
      - build:initrd
      - build:qemu
    cmds:
      - cmd: 'echo "âœ“ Build complete"'

  build:shim:
    desc: Build containerd shim binary (static, Linux x86_64)
    sources:
      - cmd/containerd-shim-qemubox-v1/**
      - internal/**
      - pkg/**
      - go.mod
      - go.sum
    generates:
      - "{{.OUTPUT_DIR}}/containerd-shim-qemubox-v1"
    cmds:
      - task: build:go
        vars:
          NAME: containerd-shim-qemubox-v1
          OUT: containerd-shim-qemubox-v1
          PKG: ./cmd/containerd-shim-qemubox-v1
          GO_STATIC_TAGS: '-tags "osusergo netgo static_build"'

  build:vminitd:
    desc: Build vminitd binary (static, Linux x86_64)
    sources:
      - cmd/vminitd/**
      - internal/**
      - pkg/**
      - go.mod
      - go.sum
    generates:
      - "{{.OUTPUT_DIR}}/vminitd"
    cmds:
      - task: build:go
        vars:
          NAME: vminitd
          OUT: vminitd
          PKG: ./cmd/vminitd
          GO_STATIC_TAGS: '-tags "osusergo netgo static_build"'

  build:initrd:
    desc: Build initrd image
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Building initrd..."
        {{.BUILDX}} build \
          --file Dockerfile \
          --target initrd \
          --platform linux/amd64 \
          --cache-from type=local,src={{.BUILDKIT_CACHE_INITRD}} \
          --cache-to type=local,dest={{.BUILDKIT_CACHE_INITRD}},mode=max,compression=zstd \
          --build-arg KERNEL_VERSION=6.18 \
          --build-arg KERNEL_ARCH=x86_64 \
          --build-arg KERNEL_NPROC=8 \
          --output type=local,dest={{.OUTPUT_DIR}} \
          .
        echo "âœ“ Initrd built: _output/qemubox-initrd"

  build:kernel:
    desc: Build kernel
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Building kernel..."
        {{.BUILDX}} build \
          --file Dockerfile \
          --target kernel \
          --platform linux/amd64 \
          --cache-from type=local,src={{.BUILDKIT_CACHE_KERNEL}} \
          --cache-to type=local,dest={{.BUILDKIT_CACHE_KERNEL}},mode=max,compression=zstd \
          --build-arg KERNEL_VERSION=6.18 \
          --build-arg KERNEL_ARCH=x86_64 \
          --build-arg KERNEL_NPROC=8 \
          --output type=local,dest={{.OUTPUT_DIR}} \
          .
        echo "âœ“ Kernel built: _output/qemubox-kernel-x86_64"

  build:qemu:
    desc: Build QEMU binaries and firmware (qemu-system-x86_64, BIOS files)
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Building QEMU..."
        {{.BUILDX}} build \
          --file Dockerfile.qemu \
          --target extract \
          --platform linux/amd64 \
          --cache-from type=local,src={{.BUILDKIT_CACHE_QEMU}} \
          --cache-to type=local,dest={{.BUILDKIT_CACHE_QEMU}},mode=max,compression=zstd \
          --build-arg QEMU_VERSION=10.2.0 \
          --build-arg QEMU_JOBS=8 \
          --output type=local,dest={{.OUTPUT_DIR}} \
          .
        echo "âœ“ QEMU built: _output/bin/qemu-system-x86_64"
        echo "âœ“ QEMU firmware: _output/share/qemubox/qemu/"

  # ==========================================================================
  # Development Tasks
  # ==========================================================================

  menuconfig:
    desc: Configure kernel (requires KERNEL_VERSION and KERNEL_ARCH env vars)
    preconditions:
      - sh: "[ -n \"${KERNEL_VERSION:-}\" ]"
        msg: "KERNEL_VERSION environment variable must be set"
      - sh: "[ -n \"${KERNEL_ARCH:-}\" ]"
        msg: "KERNEL_ARCH environment variable must be set"
    interactive: true
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Building menuconfig environment..."
        {{.BUILDX}} build \
          --file Dockerfile \
          --target kernel-build-base \
          --platform linux/amd64 \
          --cache-from type=local,src={{.BUILDKIT_CACHE_KERNEL}} \
          --cache-to type=local,dest={{.BUILDKIT_CACHE_KERNEL}},mode=max,compression=zstd \
          --build-arg KERNEL_VERSION=${KERNEL_VERSION} \
          --build-arg KERNEL_ARCH=${KERNEL_ARCH} \
          --build-arg KERNEL_NPROC=${KERNEL_NPROC:-8} \
          --output type=docker,name=qemubox-menuconfig \
          .
        echo "ðŸ³ Starting kernel menuconfig..."
        echo "   Use arrow keys to navigate, Space to select, Enter to confirm"
        echo "   Press '/' to search for options"
        echo ""
      - |
        {{.DOCKER}} run --rm -it \
          -v ./build/kernel:/config \
          -w /usr/src/linux \
          -e KCONFIG_CONFIG=/config/config-${KERNEL_VERSION}-${KERNEL_ARCH} \
          -e TERM=${TERM:-xterm-256color} \
          qemubox-menuconfig \
          bash -c "make ARCH=${KERNEL_ARCH} menuconfig && cp .config /config/config-${KERNEL_VERSION}-${KERNEL_ARCH}"

  # ==========================================================================
  # Validation Tasks
  # ==========================================================================

  validate:
    desc: Run all validation checks
    cmds:
      - task: lint
      - task: verify:vendor

  lint:
    desc: Lint code
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ” Running golangci-lint with config: .golangci.yml"
        GOOS=linux golangci-lint run --config .golangci.yml ./...
        echo "âœ“ Linting passed"

  integration:
    desc: Build release tarball and run containerd integration test
    vars:
      VERSION: '{{.VERSION | default "ci"}}'
      INTEGRATION_IMAGE: '{{.INTEGRATION_IMAGE | default "ghcr.io/aledbf/qemubox/sandbox:latest"}}'
      INTEGRATION_RUNTIME: '{{.INTEGRATION_RUNTIME | default "io.containerd.qemubox.v1"}}'
      INTEGRATION_SNAPSHOTTER: '{{.INTEGRATION_SNAPSHOTTER | default "nexus-erofs"}}'
    cmds:
      - task: release
        vars:
          VERSION: "{{.VERSION}}"
      - |
        set -eou pipefail
        VERSION="{{.VERSION}}"
        RELEASE_NAME="qemubox-${VERSION}-linux-x86_64"
        TARBALL="{{.OUTPUT_DIR}}/release/${RELEASE_NAME}.tar.gz"

        if [ ! -f "${TARBALL}" ]; then
          echo "ðŸ‘¹ Error: release tarball not found: ${TARBALL}"
          exit 1
        fi

        WORKDIR="$(mktemp -d)"
        trap 'rm -rf "${WORKDIR}"' EXIT

        echo "ðŸ“¦ Verifying QEMU firmware in build output..."
        if [ -d "{{.OUTPUT_DIR}}/share/qemubox/qemu" ]; then
          ls -la "{{.OUTPUT_DIR}}/share/qemubox/qemu"
        else
          echo "ðŸ‘¹ Error: {{.OUTPUT_DIR}}/share/qemubox/qemu not found"
          exit 1
        fi

        TARBALL_LIST="${WORKDIR}/tar.list"
        if ! tar -tzf "${TARBALL}" > "${TARBALL_LIST}"; then
          echo "ðŸ‘¹ Error: failed to read tarball contents"
          exit 1
        fi

        if ! grep -q "usr/share/qemubox/qemu/bios-256k.bin" "${TARBALL_LIST}"; then
          echo "ðŸ‘¹ Error: bios-256k.bin missing from release tarball"
          grep "usr/share/qemubox/qemu" "${TARBALL_LIST}" || true
          exit 1
        fi

        tar -xzf "${TARBALL}" -C "${WORKDIR}"

        SUDO="${SUDO:-sudo}"
        ${SUDO} systemctl stop qemubox-containerd || true
        ${SUDO} systemctl stop qemubox-buildkit || true
        ${SUDO} systemctl stop qemubox-nexus-erofs-snapshotter.service || true
        ${SUDO} "${WORKDIR}/${RELEASE_NAME}/install.sh"
        ${SUDO} systemctl enable --now qemubox-containerd
        ${SUDO} systemctl reset-failed qemubox-containerd || true
        ${SUDO} systemctl enable --now qemubox-nexus-erofs-snapshotter.service
        ${SUDO} systemctl reset-failed qemubox-nexus-erofs-snapshotter.service || true

        if [ ! -e /dev/vsock ]; then
          echo "ðŸ‘¹ Error: /dev/vsock not found"
          ${SUDO} lsmod | grep vhost_vsock || true
          exit 1
        fi

        echo "âœ“ /dev/vsock present"
        ${SUDO} lsmod | grep vhost_vsock || true

        SOCKET="/var/run/qemubox/containerd.sock"

        for _ in $(seq 1 30); do
          if [ -S "${SOCKET}" ]; then
            break
          fi
          sleep 1
        done

        if [ ! -S "${SOCKET}" ]; then
          echo "ðŸ‘¹ Error: containerd socket not ready"
          ${SUDO} systemctl status qemubox-containerd || true
          exit 1
        fi

        CTR_BIN="/usr/share/qemubox/bin/ctr"
        CTR_NAMESPACE="qemubox-ci"
        CTR_ID="qbx-ci-$(date +%s)"

        ${SUDO} "${CTR_BIN}" \
          --address "${SOCKET}" \
          --namespace "${CTR_NAMESPACE}" \
          images pull \
          --snapshotter "{{.INTEGRATION_SNAPSHOTTER}}" \
          "{{.INTEGRATION_IMAGE}}"

        cleanup_ctr() {
          # Kill the task
          ${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks kill --signal SIGKILL "${CTR_ID}" >/dev/null 2>&1 || true
          # Wait for task to stop (max 10 seconds)
          for _ in $(seq 1 10); do
            TASK_STATUS=$(${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks list 2>/dev/null | awk -v id="${CTR_ID}" 'NR>1 && $1==id {print $3}')
            if [ -z "${TASK_STATUS}" ] || [ "${TASK_STATUS}" = "STOPPED" ]; then
              break
            fi
            sleep 1
          done
          ${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks delete "${CTR_ID}" >/dev/null 2>&1 || true
          ${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" containers delete "${CTR_ID}" >/dev/null 2>&1 || true
        }
        trap 'cleanup_ctr' EXIT

        ${SUDO} "${CTR_BIN}" \
          --address "${SOCKET}" \
          --namespace "${CTR_NAMESPACE}" \
          containers create --privileged \
          --snapshotter "{{.INTEGRATION_SNAPSHOTTER}}" \
          --runtime "{{.INTEGRATION_RUNTIME}}" \
          "{{.INTEGRATION_IMAGE}}" \
          "${CTR_ID}" \
          /sbin/init

        ${SUDO} "${CTR_BIN}" \
          --address "${SOCKET}" \
          --namespace "${CTR_NAMESPACE}" \
          tasks start --detach \
          "${CTR_ID}"

        STATUS=""
        for _ in $(seq 1 30); do
          STATUS=$(${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks list 2>/dev/null | awk -v id="${CTR_ID}" 'NR>1 && $1==id {print $3}')
          if [ "${STATUS}" = "RUNNING" ]; then
            break
          fi
          sleep 1
        done

        if [ "${STATUS}" != "RUNNING" ]; then
          echo "ðŸ‘¹ Error: task did not reach RUNNING state (status=${STATUS:-unknown})"
          ${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks info "${CTR_ID}" || true
          ${SUDO} "${CTR_BIN}" --address "${SOCKET}" --namespace "${CTR_NAMESPACE}" tasks list || true
          echo "---- qemubox-containerd logs ----"
          ${SUDO} journalctl -u qemubox-containerd --no-pager -n 200 || true
          echo "---- qemubox qemu.log (latest) ----"
          QEMU_LOG=$(ls -1t /var/log/qemubox/*/qemu.log 2>/dev/null | head -n 1 || true)
          if [ -n "${QEMU_LOG:-}" ]; then
            ${SUDO} tail -n 200 "${QEMU_LOG}" || true
          else
            echo "No qemu.log found under /var/log/qemubox/"
          fi
          echo "---- qemubox console.log (latest) ----"
          CONSOLE_LOG=$(ls -1t /var/log/qemubox/*/console.log 2>/dev/null | head -n 1 || true)
          if [ -n "${CONSOLE_LOG:-}" ]; then
            ${SUDO} tail -n 200 "${CONSOLE_LOG}" || true
          else
            echo "No console.log found under /var/log/qemubox/"
          fi
          exit 1
        fi

        cleanup_ctr
        trap - EXIT

        TEST_ID="qbx-ci-$(date +%s)"
        ${SUDO} env \
          PATH="${PATH}" \
          QEMUBOX_CONTAINERD_SOCKET="${SOCKET}" \
          QEMUBOX_IMAGE="{{.INTEGRATION_IMAGE}}" \
          QEMUBOX_RUNTIME="{{.INTEGRATION_RUNTIME}}" \
          QEMUBOX_SNAPSHOTTER="{{.INTEGRATION_SNAPSHOTTER}}" \
          QEMUBOX_FIFO_DIR="/run/qemubox/containerd/fifo" \
          QEMUBOX_TEST_ID="${TEST_ID}" \
          go test -v -tags=integration -count=1 ./integration -test.v || {
            echo "---- qemubox-containerd logs for ${TEST_ID} ----"
            ${SUDO} journalctl -u qemubox-containerd --no-pager -n 200 | grep "${TEST_ID}" || true
            echo "---- qemubox-containerd logs ----"
            ${SUDO} journalctl -u qemubox-containerd --no-pager -n 200 || true
            echo "---- qemubox qemu.log (latest) ----"
            QEMU_LOG=$(ls -1t /var/log/qemubox/*/qemu.log 2>/dev/null | head -n 1 || true)
            if [ -n "${QEMU_LOG:-}" ]; then
              ${SUDO} tail -n 200 "${QEMU_LOG}" || true
            else
              echo "No qemu.log found under /var/log/qemubox/"
            fi
            echo "---- qemubox console.log (latest) ----"
            CONSOLE_LOG=$(ls -1t /var/log/qemubox/*/console.log 2>/dev/null | head -n 1 || true)
            if [ -n "${CONSOLE_LOG:-}" ]; then
              ${SUDO} tail -n 200 "${CONSOLE_LOG}" || true
            else
              echo "No console.log found under /var/log/qemubox/"
            fi
            exit 1
          }

        if [ "${CLEANUP:-0}" = "1" ]; then
          ${SUDO} systemctl stop qemubox-containerd || true
          ${SUDO} systemctl stop qemubox-nexus-erofs-snapshotter.service || true
          ${SUDO} "${WORKDIR}/${RELEASE_NAME}/uninstall.sh" || true
        fi

  # ==========================================================================
  # Setup and Tool Installation
  # ==========================================================================

  setup:
    desc: Install all required development tools
    cmds:
      - |
        set -eou pipefail
        {{.SCRIPTS_DIR}}/setup

  setup:cache:
    desc: Setup BuildKit cache directory with proper permissions
    cmds:
      - |
        set -eou pipefail
        {{.SCRIPTS_DIR}}/setup-buildkit-cache

  # ==========================================================================
  # Protobuf Tasks (optional)
  # ==========================================================================

  protos:
    desc: Generate protobuf files
    sources:
      - api/**/*.proto
      - go.mod
      - go.sum
    generates:
      - api/**/*.pb.go
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Generating protobufs..."

        # protobuild requires GOPATH mode - ensure symlinks exist
        MODULE_PATH=$(grep '^module ' go.mod | awk '{print $2}')
        GOPATH_DIR="${HOME}/go/src/${MODULE_PATH}"

        if [ ! -d "${GOPATH_DIR}" ]; then
          echo "  â†’ Creating GOPATH symlink for protobuild..."
          mkdir -p "$(dirname "${GOPATH_DIR}")"
          ln -sfn "$(pwd)" "${GOPATH_DIR}"
          echo "    âœ“ Symlink created: ${GOPATH_DIR} -> $(pwd)"
        fi

        # Create symlink for containerd/api dependency (needed for proto imports)
        CONTAINERD_API_DIR="${HOME}/go/src/github.com/containerd/containerd/api"
        if [ ! -d "${CONTAINERD_API_DIR}" ]; then
          echo "  â†’ Creating containerd/api symlink for proto imports..."
          CONTAINERD_API_MOD=$(go list -m -f '{{.Dir}}' github.com/containerd/containerd/api)
          mkdir -p "$(dirname "${CONTAINERD_API_DIR}")"
          ln -sfn "${CONTAINERD_API_MOD}" "${CONTAINERD_API_DIR}"
          echo "    âœ“ Symlink created: ${CONTAINERD_API_DIR}"
        fi

        # Save original directory
        ORIGINAL_DIR="$(pwd)"

        # Run protobuild from GOPATH location (required for correct import paths)
        # Note: We must run in a subshell with PWD set to prevent symlink resolution
        (
          cd "${GOPATH_DIR}/api"
          export PATH="${GOPATH_DIR}/bin:${HOME}/go/bin:${PATH}"
          export PWD="${GOPATH_DIR}/api"

          # Run protobuild - it should use GOPATH paths
          protobuild --quiet ${MODULE_PATH}/api/...
        )

        # Fix Go acronyms in generated files
        go-fix-acronym -w -a '^Os' $(find api/ -name '*.pb.go')
        go-fix-acronym -w -a '(Id|Io|Uuid|Os)$$' $(find api/ -name '*.pb.go')

        echo "âœ“ Protobufs generated"

  check:protos:
    desc: Check if protobufs need regeneration
    cmds:
      - task: protos
      - |
        set -eou pipefail
        echo "ðŸ³ Checking protobuf changes..."
        if [ -n "$(git status --short | grep '.pb.go')" ]; then
          echo "ðŸ‘¹ Error: Protobuf files are out of date"
          echo "   Run 'task protos' to regenerate"
          exit 1
        fi
        echo "âœ“ Protobufs are up to date"

  # ==========================================================================
  # Cleanup Tasks
  # ==========================================================================

  clean:
    desc: Clean build artifacts
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ§¹ Cleaning build artifacts..."
        rm -rf {{.OUTPUT_DIR}}
        echo "âœ“ Clean complete"

  # ==========================================================================
  # Utility Tasks
  # ==========================================================================

  setup:buildx:
    desc: Setup Docker Buildx builder for qemubox
    cmds:
      - |
        set -eou pipefail
        BUILDER_NAME="qemubox-builder"

        if docker buildx inspect "${BUILDER_NAME}" &>/dev/null; then
          echo "âœ“ Builder '${BUILDER_NAME}' already exists"
          docker buildx use "${BUILDER_NAME}"
        else
          echo "â†’ Creating builder '${BUILDER_NAME}'..."
          docker buildx create \
            --name "${BUILDER_NAME}" \
            --driver docker-container \
            --driver-opt network=host \
            --driver-opt image=moby/buildkit:latest \
            --buildkitd-flags '--allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host' \
            --use
          docker buildx inspect --bootstrap
          echo "âœ“ Builder '${BUILDER_NAME}' created and active"
        fi

  verify:vendor:
    desc: Verify go.mod/go.sum are up to date
    cmds:
      - |
        set -eou pipefail
        echo "ðŸ³ Verifying vendor files..."
        TMPDIR=$(mktemp -d)
        trap "rm -rf $TMPDIR" EXIT

        cp -R . $TMPDIR/qemubox
        cd $TMPDIR/qemubox
        {{.GO}} mod tidy
        {{.GO}} mod verify

        if ! diff -u go.mod "{{.ROOT_DIR}}/go.mod"; then
          echo "ðŸ‘¹ Error: go.mod is out of date"
          echo "   Run 'go mod tidy' to update"
          exit 1
        fi

        if ! diff -u go.sum "{{.ROOT_DIR}}/go.sum"; then
          echo "ðŸ‘¹ Error: go.sum is out of date"
          echo "   Run 'go mod tidy' to update"
          exit 1
        fi

        echo "âœ“ Vendor files are up to date"

  # ==========================================================================
  # All-in-one Tasks
  # ==========================================================================

  all:
    desc: Build and validate everything
    cmds:
      - task: build
      - task: validate
      - cmd: echo "âœ“ All tasks complete"

  default:
    desc: Default task (build everything)
    cmds:
      - task: build

  # ==========================================================================
  # Release Tasks
  # ==========================================================================

  release:
    desc: Create release tarball
    vars:
      VERSION:
        sh: echo "${VERSION:-$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo dev)}"
    cmds:
      - task: build
      - |
        set -eou pipefail
        VERSION="{{.VERSION}}" {{.SCRIPTS_DIR}}/release

  release:image:
    desc: Build and push sandbox image to GitHub Container Registry
    vars:
      VERSION:
        sh: echo "${VERSION:-$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo dev)}"
      GITHUB_REPOSITORY: '{{.GITHUB_REPOSITORY | default "aledbf/qemubox"}}'
      IMAGE: 'ghcr.io/{{.GITHUB_REPOSITORY}}/sandbox'
    cmds:
      - |
        set -eou pipefail
        echo "Building {{.IMAGE}}:{{.VERSION}}"
        {{.DOCKER}} build --platform linux/amd64 \
          --label "org.opencontainers.image.version={{.VERSION}}" \
          --label "org.opencontainers.image.source=https://github.com/{{.GITHUB_REPOSITORY}}" \
          --label "org.opencontainers.image.description=Sandbox image for qemubox" \
          -t {{.IMAGE}}:{{.VERSION}} \
          images/sandbox
      - |
        set -eou pipefail
        echo "Tagging {{.IMAGE}}:{{.VERSION}} as latest"
        {{.DOCKER}} tag {{.IMAGE}}:{{.VERSION}} {{.IMAGE}}:latest
      - |
        set -eou pipefail
        echo "Pushing {{.IMAGE}}:{{.VERSION}}"
        {{.DOCKER}} push {{.IMAGE}}:{{.VERSION}}
        {{.DOCKER}} push {{.IMAGE}}:latest
        echo ""
        echo "Released:"
        echo "  {{.IMAGE}}:{{.VERSION}}"
        echo "  {{.IMAGE}}:latest"
